<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Éditeur de Races - EcoSim</title>
    
    <link rel="stylesheet" href="menu-style.css">
    <link rel="stylesheet" href="step1-style.css"> 
    
    <style>
        /*
         * ===================================================================
         * === STYLES FROM editeur.css (MERGED) ===
         * ===================================================================
        */

        /* Utilisation des polices globales */
        html, body {
            font-family: var(--font-body);
        }

        /* Adaptation du conteneur principal de l'éditeur */
        .editor-wrapper {
            margin-left: 160px; /* Doit correspondre à la largeur du .floating-menu */
            width: calc(100% - 160px);
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 1em;
            box-sizing: border-box;
            overflow-y: auto; /* Permet le défilement du contenu de l'éditeur */
            background-color: var(--color-parchment); /* Fond cohérent */
        }

        .editor-wrapper header { text-align: center; margin-bottom: 1em; flex-shrink: 0; }
        .editor-wrapper h1, .editor-wrapper h2, .editor-wrapper h3 { color: var(--color-royal-blue); font-family: var(--font-title); }

        .container {
            display: flex;
            flex-grow: 1;
            gap: 1em;
            overflow: hidden;
            min-height: 0;
        }

        #navigation-pane, #editor-pane, #analysis-pane {
            background-color: #f9f6ef; /* Un beige très clair pour les panneaux */
            padding: 1em;
            border-radius: 8px;
            overflow-y: auto;
            border: 1px solid var(--color-border);
        }

        #navigation-pane { flex: 0 0 320px; }
        #editor-pane { flex: 2 1 50%; }
        #analysis-pane { flex: 1 1 25%; }

        #navigation-pane ul { list-style-type: none; padding-left: 15px; }
        #navigation-pane .location-type > span, #navigation-pane .category > span { font-weight: bold; cursor: pointer; display: block; padding: 4px 0; font-family: var(--font-title); }
        #navigation-pane .location-type > span { font-size: 1.2em; }
        #navigation-pane .category > span { font-size: 1.1em; }
        #navigation-pane .building { color: var(--color-dark-text); cursor: pointer; padding: 4px 0; border-left: 3px solid transparent; padding-left: 10px; margin-left: 10px;}
        #navigation-pane .building:hover { color: var(--color-royal-blue); border-left-color: var(--color-royal-blue);}
        #navigation-pane .selected { color: var(--color-royal-blue); font-weight: bold; border-left-color: var(--color-gold); background-color: rgba(212, 160, 23, 0.1); }
        .collapsible-content { display: none; padding-left: 15px;}
        .expanded > .collapsible-content { display: block; }

        form { display: flex; flex-direction: column; gap: 1em; }
        fieldset {
            border: 1px solid var(--color-border);
            border-radius: 6px;
            padding: 1em;
            margin-bottom: 1em;
            background-color: #fff;
        }
        legend { font-weight: bold; color: var(--color-royal-blue); padding: 0 0.5em; font-family: var(--font-title); }
        label { display: flex; align-items: center; margin-bottom: 0.5em; font-weight: 500; }
        input[type="text"], input[type="number"], textarea, select {
            width: 100%;
            padding: 8px;
            background-color: #fff;
            color: var(--color-dark-text);
            border: 1px solid var(--color-border);
            border-radius: 4px;
            box-sizing: border-box;
            font-family: var(--font-body);
        }
        textarea { height: 80px; resize: vertical; }

        .job-container { margin-top: 1em; border-left: 3px solid var(--color-gold); padding-left: 1em; position: relative; padding-top: 1.5em; }
        .grid-2, .grid-3 { display: grid; gap: 1em; }
        .grid-2 { grid-template-columns: repeat(2, 1fr); }
        .grid-3 { grid-template-columns: repeat(3, 1fr); }

        .button-group { display: flex; gap: 1em; margin-top: 1em; }

        #placeholder { text-align: center; margin-top: 3em; color: #888; }

        .header-with-button { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1em; }
        .header-with-button h2 { margin: 0; }
        #add-tag-btn {
            padding: 0; width: 28px; height: 28px; font-size: 1.2em;
            line-height: 28px; border-radius: 50%; flex-shrink: 0;
        }

        #analysis-output h3 { margin-top: 20px; border-bottom: 1px solid var(--color-gold); padding-bottom: 5px; }
        #analysis-output .tag-list { list-style-type: none; padding-left: 0; }
        #analysis-output .tag-list li { padding: 5px; border-radius: 4px; margin-bottom: 5px; }
        #analysis-output .tag-orphan { color: var(--color-error); font-weight: bold; background-color: rgba(183, 28, 28, 0.1); border-left: 3px solid var(--color-error); }
        #analysis-output .tag-unused { color: #c08b00; font-weight: bold; background-color: rgba(226, 160, 74, 0.1); border-left: 3px solid #e2a04a; }
        #analysis-output .building-list { font-size: 0.9em; color: #555; padding-left: 15px; margin-top: 5px; }
        .delete-job-btn { position: absolute; top: 5px; right: 5px; }

        /* Styles de la modale */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7); display: none; justify-content: center;
            align-items: center; z-index: 1000;
        }
        .modal-content {
            background-color: var(--color-parchment); padding: 2em; border-radius: 8px;
            width: 90%; max-width: 600px; border: 2px solid var(--color-gold);
            max-height: 90vh; display: flex; flex-direction: column;
        }
        .modal-content h2 { margin-top: 0; }
        .modal-content .form-group { margin-bottom: 1em; }
        .modal-content .button-group { justify-content: flex-end; }
        .hidden { display: none; }

        .tag-widget {
            border: 1px solid var(--color-border); border-radius: 5px; padding: 1em;
            background-color: #fdfaf2;
        }
        .tag-list-container { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px; }
        .tag-item {
            display: flex; align-items: center; gap: 8px;
            background-color: #e8e0c9; padding: 5px 10px;
            border-radius: 15px; font-size: 0.9em;
        }
        .add-item-form { display: flex; gap: 10px; margin-top: 10px; }
        .add-item-form input, .add-item-form select { flex-grow: 1; }

        .delete-btn {
            cursor: pointer; background-color: var(--color-error); color: white;
            border: none; border-radius: 50%; width: 20px; height: 20px;
            display: inline-flex; justify-content: center; align-items: center;
            font-weight: bold; line-height: 1;
        }
        
        #export-modal textarea {
            width: 100%; height: 250px; background-color: #fff; color: var(--color-dark-text);
            border: 1px solid var(--color-border); border-radius: 4px;
            padding: 0.5em; box-sizing: border-box; margin-bottom: 1em; margin-top: 1em;
        }

        /* Styles pour la simulation et l'analyse */
        .simulation-table {
            width: 100%; border-collapse: collapse; margin-top: 1em; font-size: 0.9em;
        }
        .simulation-table th, .simulation-table td { border: 1px solid var(--color-border); padding: 8px; text-align: center; }
        .simulation-table th { background-color: #e8e0c9; color: var(--color-royal-blue); }
        .simulation-table td { background-color: #fff; }
        .simulation-table .stat-col { min-width: 110px; }

        .analysis-tabs { display: flex; border-bottom: 2px solid var(--color-gold); margin-bottom: 1em; }
        .analysis-tab-btn {
            padding: 10px 15px; cursor: pointer; background-color: transparent; border: none;
            color: var(--color-dark-text); border-bottom: 3px solid transparent; font-size: 1em;
            margin: 0; transition: color 0.2s, border-color 0.2s; font-family: var(--font-title);
        }
        .analysis-tab-btn:hover { color: var(--color-royal-blue); background-color: #e8e0c9; }
        .analysis-tab-btn.active { color: var(--color-royal-blue); border-bottom-color: var(--color-royal-blue); font-weight: bold; }
        .analysis-tab-content { display: none; }
        .analysis-tab-content.active { display: block; }

        .tooltip {
            display: inline-block; margin-left: 8px; color: var(--color-royal-blue); cursor: help;
            border: 1px solid var(--color-border); border-radius: 50%; width: 18px; height: 18px;
            text-align: center; line-height: 18px; font-size: 0.85em; font-weight: bold; user-select: none;
        }
        legend .tooltip { margin-bottom: 0; }

        #analysis-output .clickable-tag {
            cursor: pointer;
            font-weight: bold;
            display: block;
            padding: 6px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        #analysis-output .clickable-tag:hover {
            background-color: #e8e0c9;
        }

        /* Le contenu du dépliant est caché par défaut */
        #analysis-output .tag-info {
            display: none;
            padding: 10px 10px 10px 15px; /* haut droit bas gauche */
            margin-left: 10px;
            margin-top: 5px;
            border-left: 2px solid var(--color-gold);
            background-color: rgba(255, 255, 255, 0.5);
        }

        #analysis-output .info-list {
            list-style-type: none;
            padding-left: 10px;
            font-size: 0.9em;
            color: #333;
        }

        #analysis-output .tag-info h4 {
            margin: 10px 0 5px 0;
            font-size: 0.95em;
            color: var(--color-royal-blue);
        }

        #analysis-output .tag-info h4.required {
            color: var(--color-error);
        }

        #analysis-output .building-link {
            cursor: pointer;
            color: var(--color-dark-text);
            text-decoration: underline;
            text-decoration-color: var(--color-border);
        }

        #analysis-output .building-link:hover {
            color: var(--color-royal-blue);
            text-decoration-color: var(--color-royal-blue);
        }

        /*
         * ===================================================================
         * === STYLES SPÉCIFIQUES POUR L'ÉDITEUR DE RACES ===
         * ===================================================================
         * Utilise les variables et classes de `editeur.css` pour une base cohérente.
        */

        /* Styles pour la liste des races dans la navigation */
        #navigation-pane .race-item {
            color: var(--color-dark-text);
            cursor: pointer;
            padding: 6px 0 6px 15px;
            border-left: 3px solid transparent;
            margin-left: 5px;
            font-size: 1.1em;
        }

        #navigation-pane .race-item.race-pure {
            color: darkviolet;
        }

        #navigation-pane .race-item.race-hybrid {
            color: darkorange;
        }

        #navigation-pane .race-item:hover {
            color: var(--color-royal-blue);
            border-left-color: var(--color-royal-blue);
        }

        #navigation-pane .selected {
            color: var(--color-royal-blue) !important; /* Assurer la priorité de la couleur de sélection */
            font-weight: bold;
            border-left-color: var(--color-gold);
            background-color: rgba(212, 160, 23, 0.1);
        }

        /* Grille pour les caractéristiques numériques */
        .grid-5 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1em;
        }

        /* Styles pour les listes de noms/prénoms */
        .names-container {
            display: flex;
            flex-direction: column;
            gap: 1em;
        }

        .names-list {
            min-height: 100px;
            max-height: 200px;
            border: 1px solid var(--color-border);
            padding: 0.5em;
            border-radius: 4px;
            overflow-y: auto;
            background-color: #fff;
        }

        /* Styles pour le widget de compatibilité */
        #compatibilites-widget .tag-list-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        #compatibilites-widget .tag-item {
             display: flex;
            align-items: center;
            gap: 8px;
            background-color: #d1c4e9; /* Un violet clair pour la compatibilité */
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.95em;
            border: 1px solid #b39ddb;
        }

        /* Styles pour le widget de bonus (kv = key-value) */
        .keyvalue-widget {
            border: 1px solid var(--color-border); border-radius: 5px; padding: 1em;
            background-color: #fdfaf2;
        }
        .kv-list-container {
             display: flex; flex-direction: column; gap: 8px; margin-bottom: 10px;
        }
        .kv-item {
            display: flex; align-items: center; gap: 10px;
            background-color: #e8e0c9; padding: 8px;
            border-radius: 5px; font-size: 0.9em;
        }
        .kv-item .kv-key {
            font-weight: bold;
            flex-basis: 120px;
            flex-shrink: 0;
        }
         .kv-item .kv-value {
            flex-grow: 1;
            width: 60px;
        }

        /* Analyse des compatibilités */
        #analysis-output ul {
            list-style-type: none;
            padding-left: 0;
        }

        #analysis-output li {
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 6px;
            border-left: 3px solid;
        }

        #analysis-output .analysis-ok {
            background-color: rgba(76, 175, 80, 0.1);
            border-color: #4CAF50;
            color: #388E3C;
        }

        #analysis-output .analysis-warning {
            background-color: rgba(255, 152, 0, 0.1);
            border-color: #FF9800;
            color: #E65100;
        }

        #analysis-output .analysis-error {
            background-color: rgba(244, 67, 54, 0.1);
            border-color: #F44336;
            color: #c62828;
        }

        #analysis-output .details {
            font-size: 0.85em;
            margin-left: 15px;
            color: #555;
        }

        /* --- STYLES AFFINÉS POUR LA GESTION DES HYBRIDES --- */
        #hybrid-management-container {
            margin-top: 1.5em;
            padding: 1.2em; /* Moins de padding */
            border-radius: 8px;
            background-color: #f7f9fc;
            border: 1px solid var(--color-border);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04); /* Ombre plus subtile */
        }

        #hybrid-management-container h3 {
            text-align: center;
            color: var(--color-dark-text);
            margin-bottom: 1.2em;
            font-size: 1.2em; /* Police plus petite */
            font-weight: 600; /* Un peu moins gras */
        }

        #hybrid-list {
            list-style-type: none;
            padding-left: 0;
            max-height: 250px;
            overflow-y: auto;
            padding-right: 8px; /* Espace pour la barre de scroll */
        }

        /* Style de chaque carte hybride */
        #hybrid-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.7em; /* Moins d'espace entre les cartes */
            padding: 0.7em 1em; /* Padding réduit */
            border-radius: 8px; /* Coins moins arrondis */
            background: #ffffff;
            border: 1px solid #e8eaf0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease-out;
        }

        #hybrid-list li:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
        }

        /* Conteneur pour la formule de l'hybride */
        #hybrid-list .hybrid-formula {
            display: flex;
            align-items: center;
            gap: 8px; /* Espacement réduit */
            font-size: 0.9em; /* Police plus petite */
            flex-wrap: wrap; /* MODIFIÉ */
        }

        /* Style des noms de race dans la formule */
        #hybrid-list .hybrid-formula .race-name {
            background-color: rgba(74, 144, 226, 0.08);
            color: #3b73b8;
            padding: 3px 10px; /* Padding réduit */
            border-radius: 12px;
            font-weight: 500; /* Police normale */
            border: 1px solid rgba(74, 144, 226, 0.15);
        }

        #hybrid-list .hybrid-formula .operator {
            color: var(--color-dark-text);
            font-weight: 400; /* Police normale */
            font-size: 1.1em;
        }

        /* Bouton de suppression stylisé */
        #hybrid-list .delete-hybrid-btn {
            background-color: #fff1f0;
            border: 1px solid #ffccc7;
            color: #d9363e;
            width: 28px; /* Taille réduite */
            height: 28px; /* Taille réduite */
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2em;
            line-height: 28px;
            text-align: center;
            transition: all 0.2s ease;
        }

        #hybrid-list .delete-hybrid-btn:hover {
            background-color: #ff4d4f;
            color: white;
            transform: scale(1.05);
        }

        /* Formulaire d'ajout d'hybride */
        #add-hybrid-form {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px; /* Espacement réduit */
            margin-top: 1.2em; /* Marge réduite */
            padding: 0.8em; /* Padding réduit */
            background-color: transparent; /* Fond transparent */
            border: 1px dashed var(--color-border); /* Bordure plus fine */
            border-radius: 8px;
            flex-wrap: wrap; /* MODIFIÉ */
        }

        /* === BLOC CSS MODIFIÉ === */
        #add-hybrid-form select {
            flex-grow: 1;             /* Permet aux éléments de s'agrandir pour remplir l'espace */
            min-width: 120px;         /* Définit une largeur minimale pour éviter qu'ils ne soient tronqués */
            padding: 0.5em;           /* Padding réduit */
            border-radius: 4px;
            border: 1px solid var(--color-border);
            font-size: 0.9em;         /* Police plus petite */
            background-color: #fff;
        }
        /* === FIN DU BLOC MODIFIÉ === */

        #add-hybrid-form label {
            font-size: 1.2em; /* Taille réduite */
            color: #999;
            font-weight: 400;
        }

        #add-hybrid-form #add-hybrid-btn {
            padding: 0.5em 1em; /* Padding réduit */
            font-size: 0.9em; /* Police plus petite */
        }
    </style>
</head>
<body>

<nav class="floating-menu">
    <div class="menu-title">EcoSimRPG</div>
    <a href="index.html" id="nav-index">Accueil</a>
    <a href="step1.html" id="nav-step1">Étape 1<br><small>(Carte)</small></a>
    <a href="step2.html" id="nav-step2" class="nav-disabled">Étape 2<br><small>(Conf. Lieux)</small></a>
    <a href="step3.html" id="nav-step3" class="nav-disabled">Étape 3<br><small>(Gen.0)</small></a>
    <a href="step4.html" id="nav-step4" class="nav-disabled">Étape 4<br><small>(Simulation)</small></a>
    <a href="step5.html" id="nav-step5" class="nav-disabled">Étape 5<br><small>(Données)</small></a>
    <a href="editeur.html" id="nav-editor" style="border-top: 1px solid #ccc; color: #4a90e2;">Éditeur<br><small>(Bâtiments)</small></a>
    <a href="races_editor.html" id="nav-races-editor" style="color: #4a90e2;" class="active">Éditeur<br><small>(Races)</small></a>
</nav>

    <div class="editor-wrapper">

        <header>
            <h1>Éditeur de Races en Temps Réel</h1>
            <p>Charge les données depuis `races.js`. Les modifications sont sauvegardées automatiquement.</p>
             <div class="button-group" style="padding: 0 1em 1em 1em; justify-content: flex-end; margin-top: 0;">
                <button id="import-data-btn" class="btn btn-secondary">Importer un JSON</button>
                <input type="file" id="json-upload" accept=".json" style="display:none;">
                <button id="open-manage-modal-btn" class="btn btn-edit">Exporter / Gérer</button>
           </div>
        </header>
    
        <div class="container" id="editor-view">
            <div id="navigation-pane">
                <h2>Races Disponibles</h2>
                <div id="tree-container"></div>
                <div class="button-group">
                    <button id="add-race-btn" class="btn btn-primary">Ajouter une Race</button>
                </div>
            </div>
            <div id="editor-pane">
                <div id="placeholder">
                    <h2>Bienvenue dans l'éditeur de Races</h2>
                    <p>Sélectionnez une race pour commencer ou ajoutez-en une nouvelle.</p>
                </div>
                <form id="race-form" style="display:none;"></form>
            </div>
            <div id="analysis-pane">
                <div id="hybrid-management-container">
                    <h3>Gestion des Races Hybrides</h3>
                    <ul id="hybrid-list">
                        </ul>
                    <div id="add-hybrid-form" class="add-item-form">
                        <select id="parent-a-select"></select>
                        <label>+</label>
                        <select id="parent-b-select"></select>
                        <label>&rarr;</label>
                        <select id="child-race-select"></select>
                        <button id="add-hybrid-btn" class="btn btn-secondary">Ajouter</button>
                    </div>
                </div>

                <h2>Analyse des Relations</h2>
                <div id="analysis-output"></div>
            </div>
        </div>
    
        <div id="manage-data-modal" class="modal-overlay">
            <div class="modal-content">
                <h2>Gérer les Données des Races</h2>
                <p>Téléchargez vos modifications ou réinitialisez les données à leur état d'origine.</p>
                <div class="button-group">
                    <button id="reset-all-btn" class="btn btn-delete">Restaurer les Données d'Origine</button>
                    <button id="download-json-btn" class="btn btn-primary">Télécharger le JSON</button>
                    <button type="button" id="manage-modal-close-btn" class="btn btn-secondary">Fermer</button>
                </div>
            </div>
        </div>
    </div>
    
    <script src="races.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // === CONSTANTES ===
            const CUSTOM_RACES_STORAGE_KEY = 'ecoSimRPG_races_custom';
            // MODIFICATION: Ajout de la liste des caractéristiques D&D
            const DND_CHARACTERISTICS = ["Force", "Dextérité", "Constitution", "Intelligence", "Sagesse", "Charisme"];


            // --- DOM Elements ---
            const treeContainer = document.getElementById('tree-container');
            const raceForm = document.getElementById('race-form');
            const placeholder = document.getElementById('placeholder');
            const addRaceBtn = document.getElementById('add-race-btn');
            const resetAllBtn = document.getElementById('reset-all-btn');
            const analysisOutput = document.getElementById('analysis-output');
            
            const importDataBtn = document.getElementById('import-data-btn');
            const jsonUploadInput = document.getElementById('json-upload');
            const openManageModalBtn = document.getElementById('open-manage-modal-btn');
            const manageDataModal = document.getElementById('manage-data-modal');
            const manageModalCloseBtn = document.getElementById('manage-modal-close-btn');
            const downloadJsonBtn = document.getElementById('download-json-btn');

            // --- NOUVEAUX ÉLÉMENTS DOM POUR LES HYBRIDES ---
            const hybridList = document.getElementById('hybrid-list');
            const parentASelect = document.getElementById('parent-a-select');
            const parentBSelect = document.getElementById('parent-b-select');
            const childRaceSelect = document.getElementById('child-race-select');
            const addHybridBtn = document.getElementById('add-hybrid-btn');


            let ecoSimData = null;
            let selectedRaceName = null;
            let originalData = null;

            // --- Fonctions Utilitaires et de Sauvegarde ---
            const deepClone = (obj) => JSON.parse(JSON.stringify(obj));
            
            // --- NOUVELLES FONCTIONS UTILITAIRES POUR LES NOMS ---
            function getAllNames(data) {
                const allPrenomsM = new Set();
                const allPrenomsF = new Set();
                const allNoms = new Set();
                for (const raceKey in data.races) {
                    if (data.races[raceKey].prenomsM) {
                       data.races[raceKey].prenomsM.forEach(name => allPrenomsM.add(name));
                    }
                    if (data.races[raceKey].prenomsF) {
                        data.races[raceKey].prenomsF.forEach(name => allPrenomsF.add(name));
                    }
                    if (data.races[raceKey].noms) {
                        data.races[raceKey].noms.forEach(name => allNoms.add(name));
                    }
                }
                return {
                    prenomsM: Array.from(allPrenomsM),
                    prenomsF: Array.from(allPrenomsF),
                    noms: Array.from(allNoms)
                };
            }

            function pickRandomNames(namesArray, count) {
                if (!namesArray || namesArray.length === 0) return [];
                const pickedNames = [];
                for (let i = 0; i < count; i++) {
                    const randomIndex = Math.floor(Math.random() * namesArray.length);
                    pickedNames.push(namesArray[randomIndex]);
                }
                return pickedNames;
            }


            function saveCustomRacesToStorage() {
                if (ecoSimData) {
                    localStorage.setItem(CUSTOM_RACES_STORAGE_KEY, JSON.stringify(ecoSimData));
                }
            }

            function downloadJSON() {
                const jsonData = JSON.stringify(ecoSimData, null, 4);
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const date = new Date().toISOString().slice(0, 10);
                a.href = url;
                a.download = `ecosim_races_data-${date}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            function handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const newRaceData = JSON.parse(e.target.result);
                        if (newRaceData.races && newRaceData.compatibilites) {
                             if (confirm("Charger ce fichier remplacera les données de races actuelles. Continuer ?")) {
                                ecoSimData = newRaceData;
                                selectedRaceName = null;
                                renderNavigation();
                                displayRaceForm();
                                updateAnalysis();
                                renderHybridManagement();
                                saveCustomRacesToStorage();
                                alert('Données de races chargées !');
                            }
                        } else {
                            alert('Fichier JSON invalide. Il doit contenir "races" et "compatibilites".');
                        }
                    } catch (error) {
                        alert('Erreur de parsing du JSON.');
                    } finally {
                        jsonUploadInput.value = '';
                    }
                };
                reader.readAsText(file);
            }

            // --- Rendu de l'UI ---
            function renderNavigation() {
                treeContainer.innerHTML = '';
                const hybridRaces = new Set(ecoSimData.racesMixtes ? Object.values(ecoSimData.racesMixtes) : []);

                Object.keys(ecoSimData.races).sort().forEach(raceName => {
                    const raceDiv = document.createElement('div');
                    raceDiv.className = 'race-item';
                    raceDiv.textContent = raceName;
                    raceDiv.dataset.raceName = raceName;

                    if (hybridRaces.has(raceName)) {
                        raceDiv.classList.add('race-hybrid');
                    } else {
                        raceDiv.classList.add('race-pure');
                    }

                    if (raceName === selectedRaceName) {
                        raceDiv.classList.add('selected');
                    }
                    treeContainer.appendChild(raceDiv);
                });
                addNavEventListeners();
            }

            function addNavEventListeners() {
                treeContainer.querySelectorAll('.race-item').forEach(raceDiv => {
                    raceDiv.addEventListener('click', () => {
                        selectedRaceName = raceDiv.dataset.raceName;
                        document.querySelectorAll('.race-item').forEach(el => el.classList.remove('selected'));
                        raceDiv.classList.add('selected');
                        displayRaceForm();
                    });
                });
            }

            function displayRaceForm() {
                if (!selectedRaceName || !ecoSimData.races[selectedRaceName]) {
                    raceForm.style.display = 'none';
                    placeholder.style.display = 'block';
                    return;
                }

                const raceData = ecoSimData.races[selectedRaceName];
                const allRaces = Object.keys(ecoSimData.races);
                const compatibilites = ecoSimData.compatibilites[selectedRaceName] || [];

                raceForm.innerHTML = `
                    <h3>Édition de : ${selectedRaceName}</h3>
                    <fieldset>
                        <legend>Nom de la Race</legend>
                        <input type="text" id="raceName" value="${selectedRaceName}" />
                    </fieldset>
                    
                    <fieldset>
                        <legend>Caractéristiques Démographiques</legend>
                        <div class="grid-5">
                            <div><label for="ageAdulte">Âge Adulte</label><input type="number" id="ageAdulte" value="${raceData.ageAdulte || 18}"></div>
                            <div><label for="esperanceVieMax">Espérance Vie</label><input type="number" id="esperanceVieMax" value="${raceData.esperanceVieMax || 80}"></div>
                            <div><label for="dureeGestationMois">Gestation (mois)</label><input type="number" id="dureeGestationMois" value="${raceData.dureeGestationMois || 9}"></div>
                            <div><label for="ageApprentissage">Âge Apprentissage</label><input type="number" id="ageApprentissage" value="${raceData.ageApprentissage || 4}"></div>
                            <div><label for="ageTravail">Âge Travail</label><input type="number" id="ageTravail" value="${raceData.ageTravail || 14}"></div>
                        </div>
                    </fieldset>

                    <fieldset>
                        <legend>Bonus de Caractéristiques</legend>
                        ${createBonusWidget(raceData.bonusCarac || {})}
                    </fieldset>

                    <fieldset>
                        <legend>Noms et Prénoms</legend>
                        <div class="grid-3 names-container">
                            ${createNameListWidget('prenomsM', 'Prénoms Masculins', raceData.prenomsM)}
                            ${createNameListWidget('prenomsF', 'Prénoms Féminins', raceData.prenomsF)}
                            ${createNameListWidget('noms', 'Noms de Famille', raceData.noms)}
                        </div>
                    </fieldset>

                    <fieldset>
                        <legend>Compatibilité pour la Reproduction</legend>
                        ${createCompatibilityWidget(compatibilites, allRaces)}
                    </fieldset>

                    <div class="button-group">
                        <button type="button" id="delete-race-btn" class="btn btn-delete">Supprimer cette Race</button>
                    </div>
                `;

                placeholder.style.display = 'none';
                raceForm.style.display = 'flex';
                addFormEventListeners();
            }

            // === BLOC DE FONCTION MODIFIÉ ===
            function createBonusWidget(bonuses) {
                const bonusItems = Object.entries(bonuses).map(([key, value]) => `
                    <div class="kv-item" data-key="${key}">
                        <span class="kv-key">${key}</span>
                        <input type="number" class="kv-value" value="${value}">
                        <button type="button" class="delete-btn" title="Supprimer ce bonus">x</button>
                    </div>`).join('');
                
                const appliedBonuses = Object.keys(bonuses);
                const availableOptions = DND_CHARACTERISTICS
                    .filter(char => !appliedBonuses.includes(char))
                    .map(char => `<option value="${char}">${char}</option>`)
                    .join('');

                const selectElement = `<select id="new-bonus-key" ${availableOptions ? '' : 'disabled'}>${availableOptions}</select>`;
                
                const formContent = availableOptions.length > 0
                    ? `${selectElement}
                       <input type="number" id="new-bonus-value" placeholder="Valeur" value="1" style="max-width: 80px;">
                       <button type="button" class="btn btn-secondary add-btn">Ajouter</button>`
                    : `<span style="flex-grow:1; text-align:center; font-style:italic; color:#888;">Toutes les caractéristiques sont assignées.</span>`;

                return `<div id="bonus-widget" class="keyvalue-widget">
                    <div class="kv-list-container">${bonusItems}</div>
                    <div class="add-item-form">
                        ${formContent}
                    </div>
                </div>`;
            }
            // === FIN DU BLOC DE FONCTION MODIFIÉ ===


            function createNameListWidget(id, title, names) {
                return `
                    <div>
                        <label for="${id}">${title}</label>
                        <textarea id="${id}" class="names-list" spellcheck="false">${(names || []).join('\n')}</textarea>
                    </div>
                `;
            }
            
            function createCompatibilityWidget(compatibilites, allRaces) {
                const tagItems = compatibilites.map(tag => `
                    <div class="tag-item" data-tag="${tag}">
                        <span>${tag}</span><button type="button" class="delete-btn" data-tag="${tag}">x</button>
                    </div>`).join('');
            
                const raceOptions = allRaces
                    .filter(r => r !== selectedRaceName && !compatibilites.includes(r))
                    .sort()
                    .map(r => `<option value="${r}">${r}</option>`).join('');

                return `<div id="compatibilites-widget" class="tag-widget">
                    <div class="tag-list-container">${tagItems}</div>
                    <div class="add-item-form">
                        <select><option value="">Choisir une race...</option>${raceOptions}</select>
                        <button type="button" class="btn btn-secondary add-btn">Ajouter</button>
                    </div>
                </div>`;
            }


            // --- Logique de Mise à Jour ---
            function addFormEventListeners() {
                raceForm.addEventListener('change', handleFormChange);
                raceForm.addEventListener('input', handleFormChange);

                document.getElementById('delete-race-btn').addEventListener('click', deleteRace);
                
                const bonusWidget = document.getElementById('bonus-widget');
                if (bonusWidget) {
                    const addBtn = bonusWidget.querySelector('.add-btn');
                    if(addBtn) { // Le bouton peut ne pas exister si tous les bonus sont assignés
                         addBtn.addEventListener('click', () => {
                            const keyInput = document.getElementById('new-bonus-key');
                            const valueInput = document.getElementById('new-bonus-value');
                            const key = keyInput.value.trim();
                            const value = parseInt(valueInput.value, 10);

                            if (key && !isNaN(value)) {
                                if (!ecoSimData.races[selectedRaceName].bonusCarac) {
                                    ecoSimData.races[selectedRaceName].bonusCarac = {};
                                }
                                ecoSimData.races[selectedRaceName].bonusCarac[key] = value;
                                saveAndRedraw();
                            } else {
                                alert("Veuillez entrer une valeur numérique valide pour le bonus.");
                            }
                        });
                    }

                    bonusWidget.querySelector('.kv-list-container').addEventListener('click', (e) => {
                        if (e.target.classList.contains('delete-btn')) {
                            const item = e.target.closest('.kv-item');
                            const key = item.dataset.key;
                            delete ecoSimData.races[selectedRaceName].bonusCarac[key];
                            saveAndRedraw();
                        }
                    });
                     bonusWidget.querySelector('.kv-list-container').addEventListener('input', (e) => {
                        if (e.target.classList.contains('kv-value')) {
                             const item = e.target.closest('.kv-item');
                             const key = item.dataset.key;
                             const newValue = parseInt(e.target.value, 10);
                             if (!isNaN(newValue)) {
                                ecoSimData.races[selectedRaceName].bonusCarac[key] = newValue;
                                saveCustomRacesToStorage();
                             }
                        }
                    });
                }
                
                const compatWidget = document.getElementById('compatibilites-widget');
                compatWidget.querySelector('.add-btn').addEventListener('click', (e) => {
                    const select = e.target.previousElementSibling;
                    const raceToAdd = select.value;
                    if (raceToAdd) {
                        if(!ecoSimData.compatibilites[selectedRaceName]) {
                           ecoSimData.compatibilites[selectedRaceName] = [];
                        }
                        ecoSimData.compatibilites[selectedRaceName].push(raceToAdd);
                        saveAndRedraw();
                    }
                });

                compatWidget.querySelectorAll('.delete-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const raceToRemove = e.target.dataset.tag;
                        const compatList = ecoSimData.compatibilites[selectedRaceName];
                        if (compatList) {
                            const index = compatList.indexOf(raceToRemove);
                            if (index > -1) {
                                compatList.splice(index, 1);
                            }
                        }
                        saveAndRedraw();
                    });
                });
            }

            function handleFormChange(event) {
                if (!selectedRaceName) return;

                if (event.target.closest('#bonus-widget') || event.target.closest('#compatibilites-widget')) {
                    return;
                }

                const raceData = ecoSimData.races[selectedRaceName];
                
                const newName = document.getElementById('raceName').value.trim();
                if (newName && newName !== selectedRaceName) {
                    if (ecoSimData.races[newName]) {
                        alert(`La race "${newName}" existe déjà !`);
                        document.getElementById('raceName').value = selectedRaceName;
                        return;
                    }
                    
                    const oldName = selectedRaceName;
                    
                    Object.defineProperty(ecoSimData.races, newName, Object.getOwnPropertyDescriptor(ecoSimData.races, oldName));
                    delete ecoSimData.races[oldName];
                    
                    if (ecoSimData.compatibilites[oldName]) {
                        Object.defineProperty(ecoSimData.compatibilites, newName, Object.getOwnPropertyDescriptor(ecoSimData.compatibilites, oldName));
                        delete ecoSimData.compatibilites[oldName];
                    }
                    for (const key in ecoSimData.compatibilites) {
                        const compatList = ecoSimData.compatibilites[key];
                        const index = compatList.indexOf(oldName);
                        if (index > -1) {
                            compatList[index] = newName;
                        }
                    }

                    const newRacesMixtes = {};
                    for(const key in ecoSimData.racesMixtes) {
                        let [p1, p2] = key.split('-');
                        let value = ecoSimData.racesMixtes[key];
                        
                        if(p1 === oldName) p1 = newName;
                        if(p2 === oldName) p2 = newName;
                        if(value === oldName) value = newName;
                        
                        const newKey = [p1, p2].join('-');
                        newRacesMixtes[newKey] = value;
                    }
                    ecoSimData.racesMixtes = newRacesMixtes;
                    
                    selectedRaceName = newName;
                    saveAndRedraw(true);
                    return; 
                }

                raceData.ageAdulte = parseInt(document.getElementById('ageAdulte').value) || 0;
                raceData.esperanceVieMax = parseInt(document.getElementById('esperanceVieMax').value) || 0;
                raceData.dureeGestationMois = parseInt(document.getElementById('dureeGestationMois').value) || 0;
                raceData.ageApprentissage = parseInt(document.getElementById('ageApprentissage').value) || 0;
                raceData.ageTravail = parseInt(document.getElementById('ageTravail').value) || 0;
                
                raceData.prenomsM = document.getElementById('prenomsM').value.split('\n').map(n => n.trim()).filter(Boolean);
                raceData.prenomsF = document.getElementById('prenomsF').value.split('\n').map(n => n.trim()).filter(Boolean);
                raceData.noms = document.getElementById('noms').value.split('\n').map(n => n.trim()).filter(Boolean);
                
                saveCustomRacesToStorage();
                updateAnalysis();
            }

            function saveAndRedraw(redrawNav = false) {
                saveCustomRacesToStorage();
                if(redrawNav) renderNavigation();
                displayRaceForm();
                updateAnalysis();
                renderHybridManagement();
            }

            // --- Actions (Ajout/Suppression) ---
            function addRace() {
                const newRaceName = prompt("Entrez le nom de la nouvelle race :");
                if (newRaceName && !ecoSimData.races[newRaceName]) {
                    const allNames = getAllNames(ecoSimData);
                    const randomPrenomsM = pickRandomNames(allNames.prenomsM, 10);
                    const randomPrenomsF = pickRandomNames(allNames.prenomsF, 10);
                    const randomNoms = pickRandomNames(allNames.noms, 10);

                    ecoSimData.races[newRaceName] = {
                        prenomsM: randomPrenomsM, 
                        prenomsF: randomPrenomsF, 
                        noms: randomNoms,
                        ageAdulte: 18, esperanceVieMax: 80, dureeGestationMois: 9,
                        ageApprentissage: 4, ageTravail: 14,
                        bonusCarac: {}
                    };
                    ecoSimData.compatibilites[newRaceName] = [];
                    selectedRaceName = newRaceName;
                    saveAndRedraw(true);
                } else if (newRaceName) {
                    alert("Cette race existe déjà !");
                }
            }

            function deleteRace() {
                if (confirm(`Êtes-vous sûr de vouloir supprimer la race "${selectedRaceName}" ?\nCela la supprimera aussi des compatibilités et des définitions d'hybrides.`)) {
                    const raceToDelete = selectedRaceName;
                    
                    delete ecoSimData.races[raceToDelete];
                    
                    delete ecoSimData.compatibilites[raceToDelete];
                    for (const key in ecoSimData.compatibilites) {
                        const compatList = ecoSimData.compatibilites[key];
                        const index = compatList.indexOf(raceToDelete);
                        if (index > -1) compatList.splice(index, 1);
                    }

                    const newRacesMixtes = {};
                    for(const key in ecoSimData.racesMixtes) {
                        let [p1, p2] = key.split('-');
                        let value = ecoSimData.racesMixtes[key];
                        if(p1 !== raceToDelete && p2 !== raceToDelete && value !== raceToDelete) {
                            newRacesMixtes[key] = value;
                        }
                    }
                    ecoSimData.racesMixtes = newRacesMixtes;

                    selectedRaceName = null;
                    saveAndRedraw(true);
                }
            }

            function resetData() {
                if (confirm("Réinitialiser les données de races à leur état d'origine ?")) {
                    ecoSimData = deepClone(originalData);
                    selectedRaceName = null;
                    saveAndRedraw(true);
                    alert("Données de races restaurées.");
                }
            }

            // --- NOUVELLES FONCTIONS POUR LA GESTION DES HYBRIDES ---
            function renderHybridManagement() {
                hybridList.innerHTML = '';
                const allRaces = Object.keys(ecoSimData.races).sort();
                const processedKeys = new Set();
                
                if (ecoSimData.racesMixtes) {
                    for (const key in ecoSimData.racesMixtes) {
                        const [p1, p2] = key.split('-');
                        const sortedKey = [p1, p2].sort().join('-');
                        if (processedKeys.has(sortedKey)) continue;

                        const childRace = ecoSimData.racesMixtes[key];
                        const li = document.createElement('li');
                        li.innerHTML = `<div class="hybrid-formula">
                                            <span class="race-name">${p1}</span>
                                            <span class="operator">+</span>
                                            <span class="race-name">${p2}</span>
                                            <span class="operator">&rarr;</span>
                                            <span class="race-name" style="background-color: rgba(255, 241, 204, 0.8); color: #b5800a; border-color: rgba(212, 160, 23, 0.2);">${childRace}</span>
                                        </div>
                                        <button class="delete-hybrid-btn" data-key="${key}" title="Supprimer cet hybride">&times;</button>`;
                        hybridList.appendChild(li);
                        processedKeys.add(sortedKey);
                    }
                }
                
                const optionsHTML = allRaces.map(r => `<option value="${r}">${r}</option>`).join('');
                parentASelect.innerHTML = `<option value="">Parent 1</option>${optionsHTML}`;
                parentBSelect.innerHTML = `<option value="">Parent 2</option>${optionsHTML}`;
                childRaceSelect.innerHTML = `<option value="">Enfant</option>${optionsHTML}`;
            }

            function addHybrid() {
                const parentA = parentASelect.value;
                const parentB = parentBSelect.value;
                const childRace = childRaceSelect.value;

                if (!parentA || !parentB || !childRace) {
                    alert("Veuillez sélectionner les deux parents et la race enfant.");
                    return;
                }
                if (parentA === parentB) {
                    alert("Les deux parents ne peuvent pas être de la même race pour définir un hybride.");
                    return;
                }

                const key1 = `${parentA}-${parentB}`;
                const key2 = `${parentB}-${parentA}`;
                
                if (!ecoSimData.racesMixtes) ecoSimData.racesMixtes = {};
                
                ecoSimData.racesMixtes[key1] = childRace;
                ecoSimData.racesMixtes[key2] = childRace;
                
                saveAndRedraw(true);
            }

            function deleteHybrid(key) {
                if(!ecoSimData.racesMixtes) return;
                const [p1, p2] = key.split('-');
                const key1 = `${p1}-${p2}`;
                const key2 = `${p2}-${p1}`;
                delete ecoSimData.racesMixtes[key1];
                delete ecoSimData.racesMixtes[key2];
                saveAndRedraw(true);
            }


            // --- Analyse en Temps Réel ---
            function updateAnalysis() {
                let html = '<ul>';
                if (!ecoSimData || !ecoSimData.compatibilites) {
                    analysisOutput.innerHTML = '<p>Données de compatibilité non trouvées.</p>';
                    return;
                }
                const { races, compatibilites, racesMixtes } = ecoSimData;

                for (const raceA in compatibilites) {
                    const partners = compatibilites[raceA];
                    partners.forEach(raceB => {
                        const partnersOfB = compatibilites[raceB];
                        const mixedRaceKey1 = `${raceA}-${raceB}`;
                        const mixedRaceKey2 = `${raceB}-${raceA}`;

                        if (!partnersOfB || !partnersOfB.includes(raceA)) {
                            html += `<li class="analysis-error"><b>Non-réciproque:</b> ${raceA} est compatible avec ${raceB}, mais ${raceB} ne l'est pas avec ${raceA}.</li>`;
                        } 
                        else if (racesMixtes && (racesMixtes[mixedRaceKey1] || racesMixtes[mixedRaceKey2])) {
                            const mixedRace = racesMixtes[mixedRaceKey1] || racesMixtes[mixedRaceKey2];
                            if (races[mixedRace]) {
                                 html += `<li class="analysis-ok"><b>Reproduction OK:</b> ${raceA} &harr; ${raceB} &rarr; ${mixedRace} (défini et existe).</li>`;
                            } else {
                                 html += `<li class="analysis-error"><b>Race Mixte Manquante:</b> La reproduction entre ${raceA} et ${raceB} devrait produire "${mixedRace}", mais cette race n'existe pas dans la base.</li>`;
                            }
                        }
                        else {
                            html += `<li class="analysis-warning"><b>Race Mixte Non Définie:</b> ${raceA} et ${raceB} sont compatibles, mais aucune race mixte n'est définie dans \`racesMixtes\`.</li>`;
                        }
                    });
                }
                html += '</ul>';
                analysisOutput.innerHTML = html;
            }

            // --- Initialisation ---
            function init() {
                if (window.EcoSimData && window.EcoSimData.racesData) {
                    originalData = deepClone(window.EcoSimData.racesData);
                    
                    const savedData = localStorage.getItem(CUSTOM_RACES_STORAGE_KEY);
                    if (savedData) {
                        console.log("Données de races personnalisées trouvées, chargement...");
                        ecoSimData = JSON.parse(savedData);
                    } else {
                        ecoSimData = window.EcoSimData.racesData;
                    }

                    addRaceBtn.addEventListener('click', addRace);
                    resetAllBtn.addEventListener('click', resetData);
                    
                    importDataBtn.addEventListener('click', () => jsonUploadInput.click());
                    jsonUploadInput.addEventListener('change', handleFileUpload);
                    downloadJsonBtn.addEventListener('click', downloadJSON);

                    openManageModalBtn.addEventListener('click', () => manageDataModal.style.display = 'flex');
                    manageModalCloseBtn.addEventListener('click', () => manageDataModal.style.display = 'none');

                    addHybridBtn.addEventListener('click', addHybrid);
                    hybridList.addEventListener('click', (e) => {
                        if (e.target.classList.contains('delete-hybrid-btn')) {
                            deleteHybrid(e.target.dataset.key);
                        }
                    });


                    renderNavigation();
                    updateAnalysis();
                    renderHybridManagement();
                } else {
                    placeholder.innerHTML = "<h2>Erreur</h2><p>Le fichier <strong>races.js</strong> est manquant ou l'objet <strong>EcoSimData.racesData</strong> est introuvable.</p>";
                }
            }
            
            init();
        });
    </script>

</body>
</html>